\section{Architecture}
Our choice for the implementation of CORDIC algorithm for cartesian to polar
coordinates transformation is a pipelined architecture. This choice has been
driven from the typical features that pipelines can achieve. High clock
frequency and as direct consequence an high throughput. This architecture is
particularly suitable in systems that need to process continuous streams of
data, in fact the pipeline need some clock cycles to be filled and to be
flushed.

\subsection{Block Diagram}
\subsubsection{Container Module}
Our pipelined architecture consists of a container module, which has as input
two 16 bit words (x and y coordinates), clock and reset. The inputs are supposed 
to be the quantization of normalized real world values in the range \[-1, 1\]. 
The outputs are two 20 bit words, the phase and the module.

\subsubsection{Pre-Rotation Module}
Inside the container module we have two distinct types of submodule, a
Pre-Rotation module, which has as input the x and y values and as output the
extended and rotated. This module will perform the preprocessing needed to make
the algorithm converge. As we know CORDIC algorithm's convergence is guaranteed
if the inputs are in the first or the fourth quadrant of the cartesian plane.
This because the values for the rotations performed by the algorithm are fixed
and the sum of this angles converges

sum_(n=0)^âˆž tan^(-1)(1/2^n) = 1.7423...

That is almost  pi/2 in radians.

The output is extended on 20 bits becouse we have to take in account the bit
growth in the pipeline that will be of ceil(log2(n_iterations)).

The choice of the number of iterations has been done looking at the result of
the quantization of the angles. Values smaller then 2^-12 are quantized to zero,
thus steps after the 13th  will not have any influence on the output phase.

\subsubsection{Pipeline Stage}







